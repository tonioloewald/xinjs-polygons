{"mappings":";;;;;;;;;;ACAA,oDAAoD;AACpD,wCAAwC;AAYjC,SAAS,0CAAM,CAAQ,EAAE,CAAQ;IACtC,OAAO,EAAE,IAAI,EAAE,IAAI,MAAO,CAAA,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,AAAC,CAAA,EAAE,IAAI,EAAE,CAAA,IAAM,CAAA,EAAE,IAAI,EAAE,CAAA,CAAC;AAC5E;AAEO,SAAS,0CAAgB,MAAc;IAC5C,MAAM,CAAC,SAAS,SAAS,GAAG,OAAO,MAAM,KAAK,OAAO,CAAC,KAAoC;QACxF,MAAM,CAAC,GAAG,EAAE,GAAG;QACf,IAAI,MAAM,WACR,OAAO;YAAC;YAAG,OAAO;SAAK;aAClB;YACL,EAAE,KAAK;mBAAC;gBAAG,GAAG,OAAO;YAAI;YACzB,OAAO;gBAAC;gBAAG;aAAU;QACvB;IACF,GAAG;QAAC,EAAE;QAAa;KAAU;IAC7B,IAAI,QAAQ,SAAS,GACnB,MAAM,IAAI,MAAM;IAElB,IAAI,aAAa,WACf,MAAM,IAAI,MAAM;IAElB,OAAO;AACT;AAEO,SAAS,0CAAgB,MAAe;IAC7C,OAAO,OAAO,IAAI,CAAA,IAAK,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,KAAK;AAC/C;AAEO,SAAS,yCAAS,MAAe,EAAE,YAAY,GAAG;IACvD,IAAI,OAAO,SAAS,GAClB,OAAO;IAET,OAAO,OAAO,OAAO,CAAC,MAAe;QACnC,IAAI,KAAK,SAAS,GAChB,KAAK,QAAQ;aAEb,IAAI,0CAAK,GAAG,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,IAAI,WAC9B,IAAI,CAAC,EAAE,GAAG;aAEV,KAAK,QAAQ;QAGjB,OAAO;IACT,GAAG,EAAE;AACP;AAEO,SAAS,0CAAK,GAAG,MAAe;IACrC,IAAI,OAAO,SAAS,GAClB,OAAO;SAEP,OAAO,KAAK,IAAI,OAAO,OAAO,CAAC,WAAW,GAAG;QAC3C,MAAM,IAAI,UAAU,IAAI,MAAM,CAAC,OAAO,SAAS,EAAE,GAAG,MAAM,CAAC,QAAQ,EAAE;QACrE,OAAO,YAAY,0CAAM,GAAG;IAC9B,GAAG;AAEP","sources":["src/index.ts","src/polygons.ts"],"sourcesContent":["export * from './polygons'","// polygon utilies, used for cleaning up region data\n// will be broken out to its own library\n\nexport interface Point {\n  x: number,\n  y: number\n}\n\nexport type Polygon = Point[]\n\n// this is the \"area\" of the triangle formced by 0, a, and b\n// it will be negative if ab goes from right-to-left\n\nexport function _area(a: Point, b: Point): number {\n  return a.y * b.x - 0.5 * (a.x * a.y + b.x * b.y + (b.x - a.x) * (a.y - b.y))\n}\n\nexport function stringToPolygon(source: string): Polygon {\n  const [polygon, leftover] = source.split(',').reduce((acc: [Polygon, number | undefined], num: string): [Polygon, number | undefined] => {\n    const [p, x] = acc\n    if (x === undefined) {\n      return [p, Number(num)]\n    } else {\n      p.push({x, y: Number(num)})\n      return [p, undefined]\n    }\n  }, [[] as Polygon, undefined])\n  if (polygon.length < 3) {\n    throw new Error('too few coordinates (expected at least six)')\n  }\n  if (leftover !== undefined) {\n    throw new Error('odd number of coordinates (expected even)')\n  }\n  return polygon\n}\n\nexport function polygonToString(points: Polygon): string {\n  return points.map(p => `${p.x},${p.y}`).join(',')\n}\n\nexport function simplify(points: Polygon, threshold = 0.5): Polygon {\n  if (points.length < 4) {\n    return points\n  }\n  return points.reduce((poly: Polygon, p: Point): Polygon => {\n    if (poly.length < 2) {\n      poly.unshift(p)\n    } else {\n      if (area(p, poly[0], poly[1]) < threshold) {\n        poly[0] = p\n      } else {\n        poly.unshift(p)\n      }\n    }\n    return poly\n  }, [] as Polygon)\n}\n\nexport function area(...points: Polygon): number {\n  if (points.length < 3) {\n    return 0\n  } else {\n    return Math.abs(points.reduce((totalArea, p, index) => {\n      const q = index === 0 ? points[points.length - 1] : points[index - 1]\n      return totalArea + _area(p, q)\n    }, 0))\n  }\n}"],"names":[],"version":3,"file":"index.js.map"}